<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Testing Simulator: ScenarioEditor Developer Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AI Testing Simulator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__c___users_stefa_source_repos__a_i__testing__simulator__developer__documentation__scenario_editor__developer__documentation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ScenarioEditor Developer Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md11"></a>
Important Classes</h1>
<p><a href="https://github.com/jodi106/AI_Testing_Simulator/blob/main/Developer-Documentation/img/ClassDiagram-MainController.jpg">Maincontroller Diagram</a> <img src="img/ClassDiagram-MainController.jpg" alt="ClassDiagram Maincontroller" class="inline"/> <em><a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a>, along with high-level overview of important Controller classes and their relations</em></p>
<h2><a class="anchor" id="autotoc_md12"></a>
MainController</h2>
<p>The <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> is our central component. It has a reference to a ScenarioInfo object which contains the application's state and acts as the controller for the main GUI elements of our application. As such, it holds references to the buttons which allow the user to spawn entities, remove them, open their settings, open global settings, export the scenario, and much more. Most of the other controllers hold references to the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a>'s instance, which they acquire via Unity's Camera.GetComponent function. The <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> is attached to Unity's main camera. Therefore, there will exist only one instance of it over the entire runtime of our application.</p>
<p>It has a field called 'selectedEntity' to a class implementing the <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a> interface, which contains a reference to the currently selected object. This can either be <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a> or <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> (which both inherit from <a class="el" href="class_vehicle_view_controller.html" title="An abstract base class for a BaseEntity providing shared functionality for handling positions,...">VehicleViewController</a>) or a <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a>. The interface allows the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> to select it, deselect it, destroy it, tell it to open its settings, get its location and to query or set whether the object should ignore Waypoints. The following sections will give a brief introduction to the classes implementing <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a>.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
VehicleViewController</h2>
<p><a class="el" href="class_vehicle_view_controller.html" title="An abstract base class for a BaseEntity providing shared functionality for handling positions,...">VehicleViewController</a> is an abstract class that is responsible for displaying the sprite of an entity and responding to the sprite being clicked on or dragged. It does not have a reference to a model-related class. These are added in the two inheriting classes, <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a> and <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a>. Besides the sprite itself, other important fields include 'ignoreWaypoints' which determines whether the entity will snap to Waypoints when it is dragged and 'placed' which is set to false initially and becomes true once the user places a newly created entity. In turn, the RegisterEntity() method is called by an inheriting class and the entity will be added to the ScenarioInfo via the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> (setEgo or addAdversary). When an entity is clicked, it will apply a different material to the sprite, which will add a highlight effect to it.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
EgoViewController</h2>
<p><a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a> is the controller of the Ego vehicle, which will be controlled by an AI and therefore does not have a path but only a destination. The controller for the destination (displayed as an X in the application) is called <a class="el" href="class_destination_controller.html" title="Controller for the Destination of the Ego vehicle.">DestinationController</a>. An <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a> has exactly one reference to a <a class="el" href="class_destination_controller.html" title="Controller for the Destination of the Ego vehicle.">DestinationController</a> and vice versa. There can only be one Ego vehicle and therefore only one <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a>. This is ensured by the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> which will only instantiate one Ego vehicle.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
AdversaryViewController</h2>
<p>The <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> class is also implementing <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a>. Compared to Ego, an adversary does not have a destination but a path. This path is controlled by the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> class. As with Ego and <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a>, there is only one <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> for one <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> and vice versa. They also hold references to each other. Once an <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> is placed, its <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> is instantiated. The <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> is then responsible for rendering the path of an adversary. To do so, it holds a collection of WaypointViewControllers that control the interaction with the waypoints. A more detailed explanation of the interaction between <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a>, <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> and <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> will follow later.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
WaypointViewController</h2>
<p><a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> is the final class implementing <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a>. Compared to <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController(Ego)</a> and <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController(Adversary)</a>, a Waypoint is not an <a class="el" href="namespace_entity.html">Entity</a> and the <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> does not implement <a class="el" href="interface_i_base_entity_controller.html" title="Represents an interface for a base entity controller.">IBaseEntityController</a> but only <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a>. Therefore, it is missing the getEntity() method. From the perspective of the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> this distinction is irrelevant as selectedEntity is defined as <a class="el" href="interface_i_base_controller.html" title="Represents an interface for a base controller.">IBaseController</a>. The reason why <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> does not implement <a class="el" href="interface_i_base_entity_controller.html" title="Represents an interface for a base entity controller.">IBaseEntityController</a> is that an IBaseEntity has fields such as category, model, initialSpeed and color which a Waypoint does not have.</p>
<p>Similar to the other two classes, the <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> is responsible for handling the clicking and dragging of a Waypoint. It communicates with the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> to adjust the path.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
SnapController</h2>
<p>The <a class="el" href="class_snap_controller.html" title="SnapController class handles loading and updating of road and waypoint data for the map.">SnapController</a> is responsible for rendering waypoint indicators. These are the white dots that the user sees on the roads and which allow vehicles to snap to them. The user can not interact with them in any other way. On top of that, the <a class="el" href="class_snap_controller.html" title="SnapController class handles loading and updating of road and waypoint data for the map.">SnapController</a> also offers methods for finding the closest waypoint indicator to the mouse position and finding the Path between two locations. The latter is used extensively in the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a>. In order to find the path, the <a class="el" href="class_snap_controller.html" title="SnapController class handles loading and updating of road and waypoint data for the map.">SnapController</a> uses the A* algorithm.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
MVC Interactions</h1>
<p><a href="https://github.com/jodi106/AI_Testing_Simulator/blob/main/Developer-Documentation/img/ClassDiagram-Controllers.jpg">Detailled Controller classes</a> <img src="img/ClassDiagram-Controllers.jpg" alt="Class Diagram Controllers" class="inline"/> <em>Expanded views of <a class="el" href="class_vehicle_view_controller.html" title="An abstract base class for a BaseEntity providing shared functionality for handling positions,...">VehicleViewController</a>, <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> and <a class="el" href="class_ego_view_controller.html" title="Controller for the Adversary entity in the scene.">EgoViewController</a></em></p>
<p>Our application builds on top of the MVC pattern to handle the interaction between state, view, and user controls. Our controllers have references to their model counterparts, which in turn have references to the controllers through their view interfaces. We opted to make our Controller classes act both as controllers and views. Therefore, we called them ViewControllers. They are responsible both for handling interactions with their Unity GameObjects (click, drag, etc.) and reacting to changes in the model with the callbacks defined in the View interfaces. When a user interacts with a GameObject, the controller registers this and updates the model accordingly. The model then calls the corresponding callback, which leads the controller to update the GameObject. With this model, we are not limited to changing the state of a model object through the controller. For example, we could alter the state of a model object in the <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> and the changes would still be automatically reflected in the GameObject (what the user sees). <a class="el" href="class_main_controller.html" title="MainController manages the user interface and the interactions with the scenario editor.">MainController</a> has access to the models through its ScenarioInfo instance.</p>
<p>We follow the same concept for all Controllers except <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a>. The Path class has no View for callbacks and the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> therefore must always keep the visual path in sync with the model.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
An Example</h2>
<p>An <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> has a reference to an Adversary, which it either creates itself or is passed to it during construction. It also implements the <a class="el" href="interface_i_base_entity_controller.html" title="Represents an interface for a base entity controller.">IBaseEntityController</a> and <a class="el" href="interface_i_base_entity_view.html" title="Represents an interface for a base entity view.">IBaseEntityView</a> interfaces. When the user drags the Adversary GameObject associated with a controller, the onMouseDrag method (defined in the parent class <a class="el" href="class_vehicle_view_controller.html" title="An abstract base class for a BaseEntity providing shared functionality for handling positions,...">VehicleViewController</a>) is called. Under certain circumstances, the position of the Adversary is changed using IBaseEntity's setPosition method. This method will in turn call <a class="el" href="interface_i_base_view.html" title="Represents an interface for a base view.">IBaseView</a>'s (superinterface of <a class="el" href="interface_i_base_entity_view.html" title="Represents an interface for a base entity view.">IBaseEntityView</a>) onChangePosition method. The view is the AdversaryController itself. It will thereafter change the position of the GameObject. The same concept applies to changing the color, rotation, category, model, and ID of any entity.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Interaction between AdversaryViewController, PathController and WaypointViewController</h1>
<p><a href="https://github.com/jodi106/AI_Testing_Simulator/blob/main/Developer-Documentation/img/ClassDiagram-PathController.jpg">AdversaryController, PathController, WaypointViewController interaction</a> <img src="img/ClassDiagram-PathController.jpg" alt="Class Diagram Path Controller" class="inline"/></p>
<p>The interaction between <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a>, <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a>, <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> and their corresponding models Adversary, Path and Waypoint is one of the more complex parts of our application. The <a class="el" href="class_adversary_view_controller.html" title="Controller for an Adversary.">AdversaryViewController</a> has a <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a>, which is responsible for rendering the path of an Adversary. It has references to all <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> that define the path.</p>
<p>As with the other controller classes, the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> is responsible for both rendering the path and handling interactions with it. In retrospect it would have been sensible to split the two responsibilties into two separate classes as this could have reduced the complexity considerably. In order to render a path, the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> uses a Unity LineRenderer which is very simplistic and only allows changing the entire path by passing a new set of Positions to it. There are no options to remove a single link or to automatically append one to the end of it. Creating a class which wraps a linerenderer and allows for these basic operations would be a simple way of reducing LineRenderer's complexity.</p>
<p>In order to keep track of which LineRenderer position a <a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a> corresponds to, <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> maintains a List of (<a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a>, int) tuples where the int is the index of the LineRender path position. When a path operation takes place (inserting, deleting or appending a waypoint) this list, along with the Path model must be updated. Besides the LineRenderer there is also an edgecollider which must be updated after each operation as well.</p>
<p>On top of this, we also have to account for automatic lane changes on the route between two waypoints. These lane changes are returned from the <a class="el" href="class_snap_controller.html" title="SnapController class handles loading and updating of road and waypoint data for the map.">SnapController</a>'s FindPath method and must also be added in order to guarantee that the vehicle will follow the path in the Editor when a simulation is run. These must also be added to list of (<a class="el" href="class_waypoint_view_controller.html" title="The WaypointViewController class handles the behavior of a waypoint in the game. &lt;/summary.">WaypointViewController</a>, int) tuples, which also increases complexity.</p>
<p>Contrary to most of the other Controllers, a Path model does not have a View for callbacks. When a path operation takes place, the <a class="el" href="class_path_controller.html" title="This class handles the path system for an adversary in a game. It manages waypoints,...">PathController</a> must always edit the Path model and subsequently update the LineRenderer. This has implications for the generation of a Path when loading a scenario. Because the Path model class does not have callbacks, we can not simply update the model and have the changes automatically reflected in the GameObjects. Instead, we must call PathRenderer methods directly. This also increases complexity and refactoring would again lead to a much simpler solution.</p>
<p>Besides the LineRenderer, which is responsible for rendering the actual path of an entity, we also have a LineRenderer that renders a preview of a path that could be placed. This preview is renderer in the PathRenderers Update method.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Converting between Carla and Unity Coordinates</h1>
<p>We exported the PNGs of the Carla Maps at 25 pixels per meter and are rendering them at 100 pixels per Unit. This means 1 unit in Unity corresponds to 4 meters in Carla. To convert from Unity to Carla we have to multiply the coordinates by 4. Additionally, the origin used for the map is different. In Carla the map's origin is near the center of the map. In Unity we are using the top left corner of the Map as the origin. When we exported the maps, we also collected MinX, MinY, MaxX, MaxY values for each map. To convert from Unity to Carla we would have to add (minX + maxX)/2 ((minY + maxY)/2 respectively) to the x and y coordinates. Also, the y Axis is inverted between Carla and Unity. Therefore, the y value has to be inverted as well. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
